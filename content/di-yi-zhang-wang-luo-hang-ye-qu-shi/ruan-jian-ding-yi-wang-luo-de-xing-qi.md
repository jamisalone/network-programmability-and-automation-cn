---
description: The Rise of Software Defined Networking
---

# 软件定义网络的兴起

## 为什么需要网络自动化

从不同角度分析了Network Automation部署的需求：简化的网络架构从传统网络设备配置的角度来分析为什么网络自动化可以简化网络并且能够改善一次性配置的问题；确定的输出指出传统手工配置易出错的问题，指出网络自动化配置设备的确定性，大大降低了配置的出错率；

### 简化的网络架构

* 传统网络的问题
  * 大多数网络设备被配置为**独特的雪花**（unique snowflakes），即设备上的配置是一次性非标准的
  * 网络工程师以解决传输和应用问题为荣，最终，一次性的网络变更不仅使网络更难维护和管理，也更难实现自动化
* 网络自动化和管理应该从一开始就纳入新的网络架构中，但首先你需要确保对人员和工具都有恰当的预算，当预算不足时，往往工具成为第一个被削减的
  * 当你清楚_哪些特性是跨厂商的、哪些扩展是跨平台的、哪些类型的API和自动化工具能在特定网络设备平台上运行、是否有可靠的API文档、哪些库是针对指定产品_时，那么网络架构就变得简单、可重复和容易维护与管理；同时，整个网络中启用厂商专属扩展也很少；
  * 即使简化的网络架构得到部署，并且使用正确的管理和自动化工具，减少一次性配置更改也是必要的，这保证了网络配置不会再次变成**雪花**

### 确定的输出

* 手工配置带来的问题
  * 人工进行配置容易出错，错误命令的影响是灾难性的；
  * 使用CLI或GUI的能力并不能消除或降低在控制窗口中进行配置更改的出错机率；
* 使用经过验证和测试的网络自动化来进行配置变更
  * 可以实现比于手工更改配置更加可预测的行为；
  * 使得执行团队有更高可能性实现确定的配置，向保证手头任务一次性正确完成而不出现人为错误又更进一步；

### 商业敏捷性

* 传统工作流带来的业务周期长、不敏捷的问题
  * 当我们部署一个三层应用时，为什么总是需要花费很长的时间去配置网络资源，如VLANs、路由\(routes\)、防火墙策略\(FW policies\)、负载均衡策略\(load-balancing policies\)或以上所有网络资源配置
* 商业敏捷性优势
  * 网络自动化的部署，使得网络工程和运维团队可以更快地响应IT同行部署应用，更重要的是，它帮助业务变得更加敏捷；
* 现有的基础依然重要
  * 在试图过度到任何自动化流程前，无论你想使得业务更敏捷的意图有多好，明白现有的、手工的工作流程依然是非常重要的
  * 如果你现有手工的工作流理解到位，并且对它们都有一个好的记录，明白他们对业务带来的影响，那么部署自动化技术和工具时，你将更加轻松

## 网络自动化的类型

自动化等同于快速\(speed\)，可是许多网络任务不要求快速，这个就很好理解为什么一些IT团队没有看到自动化的价值。例如，VLAN创建任务似乎就不太要求“快速”。

例如设备配置\(device provisioning\)、数据收集\(data collection\)、故常排查\(troubleshooting\)、报告\(reporting\)和合规性\(compliance\)是使得自动化有意义的任务。自动化显然除了快速和敏捷外，还有许多优势，例如使得业务更加可预测和更加确定性的结果。

### 设备配置

* 最简单和最快开始网络自动化的方式之一就是网络配置文件的创建，这些网络配置文件用来初始化设备配置然后将配置上传到网络设备；
* 设备配置可以分解为两个步骤
  * 创建配置文件\(creating the configuration file\)
  * 上传配置到设备\(pushing the configuration onto the device\)
* 为了实现自动创建配置文件，我们首先需要将输入\(配置参数\)从配置的底层厂商专有语法\(CLI\)中解耦出来，这也意味着最终会得到分离的文件，其中包含VLAN、域信息、接口、路由和其他一切被配置的配置参数的值，当然还有配置模板；
* 试想：把配置模板看作是一个标准的万能模板\(standard golden template\)，用于所有设备的部署。通过利用一种叫做网络配置模板\(_network configuration templating_\)的技术，你能够快速地生成专门针对你的网络的一致的网络配置文件。这也意味着你再也不用使用记事本\(Notepad\)，在一个文件之间复制粘贴配置了；
* 两种简化使用带有变量\(数据输入\)的配置模板的工具是Ansible和Salt。在不到几秒钟的时间里，这些工具可以可预测地、可靠地生成数百个配置文件；

拿Cisco的VLAN配置举例，把当前的VLAN配置分解成一个模板和单独的变量\(输入数据\)文件【如果看不懂其中某些内容，不用担心，后续还会有文章深入解释】：

* 配置文件

  当我们从CLI命令中解耦数据，该配置文件会被转换为两个文件—一个模板文件和一个数据\(变量\)文件

  ```text
  hostname leaf1
  ip domain-name ntc.com
  !
  vlan 10
     name web
  !
  vlan 20
     name app
  !
  vlan 30
     name db
  !
  ```

* YAML变量文件

  ```text
  ---
  hostname leaf1
  domain_name: ntc.com
  vlans:
  	- id: 10
  		name: web
  	- id: 20
  		name: app
  	- id: 30
  		name: db
  ```

* 模板文件

  ```text
  !
  hostname {{ inventory_hostname }}
  ip domain-name {{ domain_name }}
  !
  !
  {% for vlan in vlans %}
  vlan {{ vlan.id }}
  	name {{ vlan.name }}
  {% endfor %}
  !
  ```

  * `{{ variable_name }}` — **Jinja**变量，当模板被填入输入数据，该变量就被变量文件中存储的数据填充；
  * 除了扁平的YAML文件，也可以使用脚本从外部系统如网络管理系统\(NMS\)或者IP地址管理系统\(IPAM\)来获取该类信息；
  * 当团队想要增加一个新VLAN时，就只需要修改变量文件，然后使用Ansible或其他工具来重新生成新的配置文件；同时，变量文件的存储方式也是模板化的，配置修改也变得更简单和轻松；

### 数据收集

* 监控工具通常使用SNMP，这些工具对某些_**MIBs\(Management Information Bases\)进行信息轮询\(poll\)，并将数据返回给工具，返回的数据它可能或多或少于你**需要的数据_；
* 传统数据轮询的带来问题：当设备接口状态信息被轮询时，可能是`show interface`命令返回的信息，但如果我们对信息进行筛选时，例如只需要_interface resets_而不是_CRC errors_、_jumbo frames_或_output errors_等；更进一步，如果我们想要查看使能了CDP/LLDP协议的接口的_interface resets_，并且我们需要立即查看而不是在下一个轮询周期 \(next polling cycle\)内查看呢？网络自动化可以对这带来什么帮助？
* 通过开源工具和技术，我们可以定制 — 需要获取哪些数据、在什么时间获取这些数据、数据使用什么格式存储和数据在收集后如何被使用，定制这些内容来确保返回数据的价值最大化；
* 简单的例子
  * 一段使用Python库netmiko编写的从IOS设备收集数据的脚本

    ```text
    from netmiko import Connecthandler

    device = ConnectHandler(device_type='cisco_ios', ip='csr1', username='ntc',
    												password='ntc123')
    output = device.send_command('show version')

    print(output)
    ```

    output输出中会包含在IOS设备上show version命令输出的内容，并且我们能够从输出内容中分解出满足需求的参数（数据）。

    在本例中，描述的是一种从设备上拉取数据 \(pulling the data off\)的过程，这并不是对所有环境的理想操作，但仍对多数环境合适。要知道的是，较新的设备开始支持一种推送模式 \(push model\)，通常指自动数据流记录 \(streaming telemetry\)，即设备将自身事实数据如接口状态上传给一个你所选择的应用服务器。
* 开源工具和定制化工具
  * 网络设备内埋藏了巨量的静态和瞬时数据，使用开源工具或定制属于个人或企业的工具来获取这些数据；
  * 这类数据的例子有：BGP表中的活动条目、OSPF邻接关系、活动的邻居、接口统计、特定的计数器和重置，甚至是来自新平台上特定应用集成电路 \(application-specific integrated circuits，ASIC\) 本身的计数器；
  * 一般事实和设备特性数据也可以被收集，例如序列号、主机名、正常运行时间、操作系统版本和硬件平台等；可以收集的数据是列举不完的；

### 迁移

* 平台的迁移从来都不是一件易事。迁移任务可能是同厂商平台的迁移也可能是跨厂商平台的迁移
  * 不同形式的自动化可能用于构造配置模板 \(configuration template\)，就像【设备配置】中所举的例子，对于所有类型的网络设备和操作系统，都可以通过已定义的和常见的输入集 \(defined and common set of inputs\)来生成各个厂商设备的配置模板。
* 厂商专有扩展，在迁移导出到配置文件 \(configuration file\)时，需要对他们做出单独解释
* 自建迁移工具比厂商更容易 — 因为个人或组织只需要考虑有限的设备特性而厂商需要考虑覆盖自己产品的所有特性，厂商更关注的是自己生产的设备，所有厂商的迁移工具的目标群体并不是管理多厂商环境的网工们。
* 自动化的灵活性除了使迁移任务受益，也能够帮助**灾难恢复** \(**灾备**，DR, disaster recovery\)
  * 在生产环境和灾备数据中心中，使用不同型号交换机或不同厂商的交换机是常见的。
  * 利用迁移工具的这种灵活性，当一台设备因为某原因宕机，备用机器是不同平台的设备，此时就可以快速利用通用数据模型 \(common data model，可以认为是一种参数输入的形式\) 迅速生成一个适用于备用设备的新配置
* 当开始实施网络自动化时，在你开始着手在CLI敲入命令或在各个平台写代码前，思考任务并以厂商中立的人类可读格式记录它们是极其重要的。思考需要一个在一个抽象层面上，并且认真考虑所需完成的任务，只有个人和组织或许更有动力来完成一个多设备自动化。

### 配置管理

* 配置管理是自动化最常见的任务
* 当提到配置管理时，通常指部署、上传和管理设备的配置状态。这包括从VLAN配置这类的简单配置任务到复杂的工作流，如配置架顶交换机、防火墙、负载均衡和高级安全基础设置，再到配置三层架构应用 \(three-tier applications\)
* 这里作者提出一个有意思的观点：_As you can see already through the different forms of automation that are read-only, you do not need to start your automation journey by pushing configurations._ 作者告诉读者学习网络自动化不一定是从推送配置开始，原因在于我们只是在花费无数时间推送相同的变化到一些有限数量的路由器和交换机。

后面的三个类型承接上面的【Data Collection】

### 合规性

* 与许多形式的自动化一样，使用任何类型的自动化工具进行配置变更都被视为一种风险，但是它的风险程度还是低于手工配置的风险程度的
  * 虽然进行手动更改可以说风险更大，但可以选择从数据收集、监控和配置构建开始，这些都是只读和低风险的操作
  * 笔者理解的只读就是，一种查询式或者报告式的自动化，更多是一种提供信息、查询信息的自动化，帮助网工或管理员更快速的排查故障，不涉及网路拓扑、配置的变更
* 处于收集状态的数据的使用是一个低风险案例，该案例是配置合规性检查\(configuration compliance checks\)和配置验证\(configuration validation\)

  * 部署的配置是否符合安全要求？
  * 是否配置了所需的网络？
  * 某个协议是否被禁用？

  当你能够控制正在部署的工具时，就更有可能验证某些配置是正确还是错误。可以从小事做起，例如从合规性检查开始，然后根据需要逐步增加更多的检查。

* 根据你正在检查的配置的合规性，由你决定下一步操作—它或许只是被记录\(gets logged\)下来，或许是执行一个能使你的应用程序能够自动修复的复杂操作。
* 建议
  * 网络自动化最好总是从简单的任务开始，但“意识到可能的情况\(being aware of what’s possible\)”也会增加重要价值；
  * 例如，如果只是通过记录或打印消息以查看接口的MTU值，但你已经准备好，当MTU不是理想值时，可以自动重新配置为正确的值；只需要在以配置的log/print消息下面增加几条消息用来使能自动配置的功能；
  * 所以，虽然重要的是从小的简单任务开始，但是要思考在未来还需要完善什么功能；

### 报告

* 一旦数据收集自动化，就想要开始构建一个自定义**动态**的报告；收集的数据被返回，一方面可能作为另一些配置管理任务的输入，另一方面可能也仅仅是用于创建报告。
* 报告可以很容易地由**模板**和将要被插入模板的**瞬时数据**\(来自设备\)生成，创建和使用报告模板的过程与前面的VLAN创建过程的例子是一样的。
* 由于使用基于文本的模板的简单特性，它可以以任何你想要的格式制作报告，包括但不限于：

  * 简单的文本文件
  * 可以轻松地在Github或其它Markdown阅读器上查看的Markdown文件
  * 为了方便查看而部署在web服务器上的HTML报告

  格式的选择都取决于你的要求。

* 事实上，我们也可以使用一个数据集合来生成任意类型的报告，可能是一些技术性报告和一些高级的管理报告。

### 排障

* 传统排障我们不仅需要人工监视，还需要网工介入来寻找故障所在，而每个网工基本上都有自己的排障方法；一旦能够访问实时数据并且不需要对这些数据进行手工解析，自动排障就成为现实。
* 以OSPF排障为例，在任何环境中，需要考虑OSPF的一致性检查，例如邻接关系建立时需要查看是否为同一子网、接口是否有相同MTU、是否有相同的计时器和相同网络类型等；在传统排障时，我们需要分别登录设备，用CLI命令查看并对比信息，我们能否使用脚本或工具来代替手工排障？
* OSPF的邻接关系建立过程的一致性检查只是排障问题的冰山一角，即使加入了BGP邻接关系建立或者如果形成邻接关系，或检查路由表是否与预期相同等情况，依然也只是浮于诊断和排障任务的表面；
* 当你开始考虑所有可能的自动化类型时，开始想象一个闭环系统，这样的系统是以自动化的方式收集数据，然后以自动化的方式处理和分析数据，然后你以自动化的方式使用高级分析来排除故障。当这些事情开始以统一的方式发生在一起时，这就变成了一个闭环，完全改变了组织内的运维方式。

### 小结

正如网络自动化有多种类型，它不仅限于更快的配置部署。下面的话题主要关于**自动化工具**和**应用程序**与网络设备**通信**的几种**不同方式**，从SSH开始，到NETCONF和基于HTTP的RESTful API。

## 管理平面从SNMP到设备APIs的演变

如果想要改善日常管理和运维网络的方式，改善必须从如何与被管理的底层设备交互\(interface with\)开始。这个接口\(interface\)是你和自动化工具与设备进行通信的方式，以执行各种类型的网络自动化，如数据收集\(data collection\)和配置管理\(configuration management\)。在本节中，将对可用于连接到网络设备管理平面的不同方法进行概述，首先从SNMP开始，然后是更现代化的方式，如NETCONF和RESTful APIs。然后，我们看看_open networking_ movement \(开放网络运动\)对网络运维和自动化的影响。

### APIs

作为网工，你需要拥抱进击的APIs，不能畏惧它们。API只是一种用于一个设备的软件和另一个设备的软件进行沟通的机制。APIs如今被用于互联网的任何角落 — 它们只是碰巧终于得到了网络厂商应用的关注。我们不久将会看到APIs将会成为管理网络设备的主要方式。

#### SNMP

* SNMP已经在网络设备上广泛部署了20多年，SNMP是一个很常用的协议，用于轮询网络设备的信息，如上/下行状态和CPU、内存和接口利用率；
* 要部署SNMP，被管理设备上必须有一个SNMP代理\(SNMP agent\)和一个网络管理站点\(Network Management Station, NMS\)，NMS是作为监视和/或控制被管理设备的服务器的设备。
* 每个被管理的网络设备都会公开出一组数据，可以通过SNMP代理\(SNMP agent\)收集和配置这些数据。通过SNMP管理的这组数据是通过管理信息库\(Management Information Bases, MIBs\)来描述和建模的。只有当有一个MIB公开了某个功能时，才能对其进行监控或管理。这包括通过SNMP进行配置更改。经常被忽略的是，SNMP不仅支持GetRequests来监控，还支持SetRequests来操作通过MIB公开的对象和变量。问题是，没有多少厂商提供通过SNMP进行配置管理的全面支持；即使有，也往往使用自定义的MIBs，从而减慢了对网络管理平台的集成过程。
* 如前所述，SNMP已经存在了几十年，但它并不是为了成为网络设备的实时程序化接口而建立的。我们已经看到供应商声称SNMP逐渐死亡，因为它涉及到下一代管理和自动化工具。尽管如此，SNMP确实存在于几乎所有的网络设备上，而且SNMP的Python库也存在--所以，如果你需要从大量的设备类型中收集基本信息，使用SNMP可能还是有意义的。

#### SSH/Telnet and the CLI

* 如果你曾管理过网络设备，就一定使用过CLI来发出命令，在设备上执行一些动作；你大概率是通过Telnet或SSH会话来输入命令的。从Telnet向SSH的迁移可以说是我们在过去十年中在网络运维方面最大的转变，这种转变不是关于运维的，而是关于安全的，确保网络设备的通信是加密的。
* CLI是为人类设计的，是为人类运维人员提供设备可用性的，然而CLI不是用来机器对机器通信的；
  * 如果在设备的CLI上执行`show`命令，会返回未处理过的原始文本，它是无结构的；
  * 解析这个无结构文本的最佳选择是使用`pipe`\( `|` \)和关键词，如`grep`，`include`和`begin`来筛查配置文本中的特定行；
* 在过去20年里面，我们只有CLI，此间逐渐出现大量的网络管理平台和自定义脚本，在SSH处理脚本和手动解析的基础上，使用CLI进行管理和自动化操作。这并不是说SSH/CLI使其无法实现自动化，相反，它使**自动化极易出错，而且很繁琐**。
* 网络厂商开始意识到这一点，现在大多数新的设备平台都有某种类型的API，可以简化机器与机器之间的通信（很多还不完善，所以一定确保去测试过你最喜好的设备API），产生了一种更简单的自动化方法，也更符合一般的软件开发原则。

#### NETCONF

* NETCONF是一种网络管理层协议。在最高层次上，它可以与SNMP相提并论，因为它们都是用来对网络设备进行配置更改和检索数据的协议。
* A few high-level points
  * NETCONF是一个**面向连接**的协议，通常利用**SSH**作为其传输方式；
  * NETCONF客户端（自动化工具/脚本）和NETCONF服务器（网络设备）之间发送的数据用**XML**编码；
  * 远程过程调用\(Remote Procedure Call, RPC\)被编码在发送到设备的XML文档中，设备会处理这些RPC；`<rpc>`元素用于封装从客户端发送到服务器的NETCONF请求；在这种情况下，将这些远程过程调用\(RPC\)视为在设备上执行预先安排的操作；RPCs是客户端向服务器进行通信的一种方式，这种方式将告诉服务器，客户端请求的结构和类型；
  * 支持的RPCs直接映射到特定设备所支持的NETCONF操作和功能。例如，如果你是在设备上进行更改，你使用`edit-config`操作。如果您要检索配置数据，您可以使用`get`或`get-config`操作。这些操作将要发送给设备的`<rpc>`元素封装在XML文档中。
* 此外，NETCONF的价值在于它**支持基于事务的更改**。这意味着，如果你在一个给定的NETCONF会话或单个XML文档中进行了多个更改，而其中一个更改失败，则完整的更改不会应用到设备上（当然，这些类型的设置通常也可以被覆盖）。这与依次发送CLI命令，最后由于打字错误或无效命令而导致部分配置不同。
* 值得指出的是，仅仅因为两个不同的设备平台支持NETCONF（或任何通用的传输方法支持NETCONF），并不意味着从工具和开发角度来看它们是兼容的。即使假设两个设备都支持相同的NETCONF特性和功能，但数据如何建模，更多的时候是厂商指定的。数据建模就是设备如何表示状态和配置数据，这将更多涉及**JSON**和**XML**以及**YANG**（一种常见的数据建模语言）的数据表示。

#### RESTful APIs

* REST\(REpresentational State Transfer\)是一种用于**设计和开发网络应用**的架构**风格**。
  * 因此，实现和坚持基于**REST架构的系统**被称为**RESTful**
  * REST是风格，RESTful是基于REST架构的系统
  * 最常见的公开API和使用REST架构风格的设备是网络控制器 \(network controller\)，也就是说，存在公开RESTful和基于HTTP的API的网络设备。
* 虽然从网络的角度来看，REST和RESTful API这些术语是新的，但当你使用网络浏览器浏览互联网时，你在日常生活中已经与许多RESTful系统进行交互了。REST是一种用于开发网络应用的风格，这种风格依赖于无状态的客户端-服务器模型\(client-server model\)，其中客户端一直跟踪会话\(session\)，而服务器上不持有客户端状态或情况\(client state or context\)。最好的是，使用的底层传输协议是最常见的HTTP。
* 这意味着RESTful API的操作就像基于HTTP的系统一样。
  * 首先，你需要一个通过URL（即SDN控制器或网络设备进行通信）访问的Web服务器
  * 其次，你需要向该URL发送相关的HTTP请求\(HTTP request\)
* Example
  * 如果你需要从SDN控制器中检索设备列表，你只需要向给定的设备URL发送一个HTTP GET，它可能看起来像这样：`http://1.1.1.1/v1/devices`。
  * 返回的响应\(response\)将是某种类型的结构化数据，如XML或JSON
* 身份验证、数据编码，以及在进行配置更改时如何发送HTTP请求（HTTP PUT/POST/PATCH）等未提及的内容将在后面文章中展现

### Open Networking运动的影响

* 所有的东西都有一个不断增长的趋势，open source， open networking，Open APIs，OpenFlow，Open Compute，Open vSwitch，OpenDaylight，OpenConfig等等，不胜枚举。虽然关于开放的定义存在争议，但有一点是肯定的：开放网络运动\(open networking movement\)正在改善网络运维和自动化方面的可能性。
* 伴随着这场运动，可以看到网络设备发生了巨大的变化，这也是作者写本书的一个主要原因。
  * 首先，现在许多设备都支持Python预置\(on-box\)。这意味着你能够将Python动态解释器预置到设备，在每个网络设备本地执行Python脚本。
  * 其次，现在许多设备都支持SNMP和SSH以外的更强大的API，例如NETCONF和基于RESTful HTTP的API。在过去18到24个月内\(该书第一版在2018年出版\)出现的许多较新的设备操作系统上都支持其中一个或两个API。
  * 最后，网络设备正在公开更多Linux内部结构，而这些内部结构在过去一直被网络运营商所隐藏。你现在可以在网络设备上进入bash shell，并通过apt和yum等包管理器发出ifconfig等命令，编写bash脚本，安装监控和配置管理工具。
* 虽然开放网络并不总是意味着互操作性，但很明显网络设备和控制器正在“开放自己”，以一种更适合增强网络自动化的程序化方式进行操作。网络设备上有许多几年前还不存在的API，从思科的NX-API、Arista的eAPI、思科的IOS-XE RESTCONF/NETCONF到任何新的SDN控制器都有API。对于作为运维人员来说，最终的结果是，当你开始使用这些API时，你可以控制你的网络，并减少今天存在的一些运维效率低下的情况。

## SDN时代的网络自动化

* 我们现在将看看即使在部署控制器解决方案（如OpenDaylight，甚至是Cisco ACI或VMware NSX等商业产品）的情况下，网络自动化的持续重要性。
* 事实是，控制器在下一代架构中变得很普遍。Cisco、Juniper、VMware、Big Switch、Plexxi、Nuage、Viptela等厂商都为其下一代解决方案提供了控制器平台，更不用说OpenDaylight和OpenContrail等开源控制器了。
* 市场上几乎所有的控制器都公开了北向RESTful API，使控制器极易实现自动化。虽然控制器本身本质上通过北向接口简化了管理和可视性，但通过控制器GUI进行的配置更改可能还是手动的和易错的。如果部署了多个来自相同或不同的厂商的pods或控制器，那么手动更改、排障和数据收集的问题就不会消失。
* 需要注意的是，即使在SDN架构和基于控制器的网络解决方案的新时代，对**自动化**、**更好的运维**和**更可预测的结果**的需求也不会消失。

