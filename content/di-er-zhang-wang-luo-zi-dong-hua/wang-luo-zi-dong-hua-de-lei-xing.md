# 网络自动化的类型

自动化等同于快速\(speed\)，可是许多网络任务不要求快速，这个就很好理解为什么一些IT团队没有看到自动化的价值。例如，VLAN创建任务似乎就不太要求“快速”。

例如设备配置\(device provisioning\)、数据收集\(data collection\)、故常排查\(troubleshooting\)、报告\(reporting\)和合规性\(compliance\)是使得自动化有意义的任务。自动化显然除了快速和敏捷外，还有许多优势，例如使得业务更加可预测和更加确定性的结果。

## Device Provisioning \| 设备配置

* 最简单和最快开始网络自动化的方式之一就是网络配置文件的创建，这些网络配置文件用来初始化设备配置然后将配置上传到网络设备；
* 设备配置可以分解为两个步骤
  * 创建配置文件\(creating the configuration file\)
  * 上传配置到设备\(pushing the configuration onto the device\)
* 为了实现自动创建配置文件，我们首先需要将输入\(配置参数\)从配置的底层厂商专有语法\(CLI\)中解耦出来，这也意味着最终会得到分离的文件，其中包含VLAN、域信息、接口、路由和其他一切被配置的配置参数的值，当然还有配置模板；
* 试想：把配置模板看作是一个标准的万能模板\(standard golden template\)，用于所有设备的部署。通过利用一种叫做网络配置模板\(_network configuration templating_\)的技术，你能够快速地生成专门针对你的网络的一致的网络配置文件。这也意味着你再也不用使用记事本\(Notepad\)，在一个文件之间复制粘贴配置了；
* 两种简化使用带有变量\(数据输入\)的配置模板的工具是Ansible和Salt。在不到几秒钟的时间里，这些工具可以可预测地、可靠地生成数百个配置文件；

拿Cisco的VLAN配置举例，把当前的VLAN配置分解成一个模板和单独的变量\(输入数据\)文件【如果看不懂其中某些内容，不用担心，后续还会有文章深入解释】：

* 配置文件

  当我们从CLI命令中解耦数据，该配置文件会被转换为两个文件—一个模板文件和一个数据\(变量\)文件

  ```text
  hostname leaf1
  ip domain-name ntc.com
  !
  vlan 10
     name web
  !
  vlan 20
     name app
  !
  vlan 30
     name db
  !
  ```

* YAML变量文件

  ```text
  ---
  hostname leaf1
  domain_name: ntc.com
  vlans:
  	- id: 10
  		name: web
  	- id: 20
  		name: app
  	- id: 30
  		name: db
  ```

* 模板文件

  ```text
  !
  hostname {{ inventory_hostname }}
  ip domain-name {{ domain_name }}
  !
  !
  {% for vlan in vlans %}
  vlan {{ vlan.id }}
  	name {{ vlan.name }}
  {% endfor %}
  !
  ```

  * `{{ variable_name }}` — **Jinja**变量，当模板被填入输入数据，该变量就被变量文件中存储的数据填充；
  * 除了扁平的YAML文件，也可以使用脚本从外部系统如网络管理系统\(NMS\)或者IP地址管理系统\(IPAM\)来获取该类信息；
  * 当团队想要增加一个新VLAN时，就只需要修改变量文件，然后使用Ansible或其他工具来重新生成新的配置文件；同时，变量文件的存储方式也是模板化的，配置修改也变得更简单和轻松；

## Data Collection \| 数据收集

* 监控工具通常使用SNMP，这些工具对某些_**MIBs\*\*\*\(Management Information Bases\)进行信息轮询\(poll\)，并将数据返回给工具，返回的数据它可能或多或少于你**需要的数据_\*；
* 传统数据轮询的带来问题：当设备接口状态信息被轮询时，可能是`show interface`命令返回的信息，但如果我们对信息进行筛选时，例如只需要_interface resets_而不是_CRC errors_、_jumbo frames_或_output errors_等；更进一步，如果我们想要查看使能了CDP/LLDP协议的接口的_interface resets_，并且我们需要立即查看而不是在下一个轮询周期 \(next polling cycle\)内查看呢？网络自动化可以对这带来什么帮助？
* 通过开源工具和技术，我们可以定制 — 需要获取哪些数据、在什么时间获取这些数据、数据使用什么格式存储和数据在收集后如何被使用，定制这些内容来确保返回数据的价值最大化；
* 简单的例子
  * 一段使用Python库netmiko编写的从IOS设备收集数据的脚本

    ```text
    from netmiko import Connecthandler

    device = ConnectHandler(device_type='cisco_ios', ip='csr1', username='ntc',
    												password='ntc123')
    output = device.send_command('show version')

    print(output)
    ```

    output输出中会包含在IOS设备上show version命令输出的内容，并且我们能够从输出内容中分解出满足需求的参数（数据）。

    在本例中，描述的是一种从设备上拉取数据 \(pulling the data off\)的过程，这并不是对所有环境的理想操作，但仍对多数环境合适。要知道的是，较新的设备开始支持一种推送模式 \(push model\)，通常指自动数据流记录 \(streaming telemetry\)，即设备将自身事实数据如接口状态上传给一个你所选择的应用服务器。
* 开源工具和定制化工具
  * 网络设备内埋藏了巨量的静态和瞬时数据，使用开源工具或定制属于个人或企业的工具来获取这些数据；
  * 这类数据的例子有：BGP表中的活动条目、OSPF邻接关系、活动的邻居、接口统计、特定的计数器和重置，甚至是来自新平台上特定应用集成电路 \(application-specific integrated circuits，ASIC\) 本身的计数器；
  * 一般事实和设备特性数据也可以被收集，例如序列号、主机名、正常运行时间、操作系统版本和硬件平台等；可以收集的数据是列举不完的；

## Migrations \| 迁移

* 平台的迁移从来都不是一件易事。迁移任务可能是同厂商平台的迁移也可能是跨厂商平台的迁移
  * 不同形式的自动化可能用于构造配置模板 \(configuration template\)，就像【设备配置】中所举的例子，对于所有类型的网络设备和操作系统，都可以通过已定义的和常见的输入集 \(defined and common set of inputs\)来生成各个厂商设备的配置模板。
* 厂商专有扩展，在迁移导出到配置文件 \(configuration file\)时，需要对他们做出单独解释
* 自建迁移工具比厂商更容易 — 因为个人或组织只需要考虑有限的设备特性而厂商需要考虑覆盖自己产品的所有特性，厂商更关注的是自己生产的设备，所有厂商的迁移工具的目标群体并不是管理多厂商环境的网工们。
* 自动化的灵活性除了使迁移任务受益，也能够帮助**灾难恢复** \(**灾备**，DR, disaster recovery\)
  * 在生产环境和灾备数据中心中，使用不同型号交换机或不同厂商的交换机是常见的。
  * 利用迁移工具的这种灵活性，当一台设备因为某原因宕机，备用机器是不同平台的设备，此时就可以快速利用通用数据模型 \(common data model，可以认为是一种参数输入的形式\) 迅速生成一个适用于备用设备的新配置
* 当开始实施网络自动化时，在你开始着手在CLI敲入命令或在各个平台写代码前，思考任务并以厂商中立的人类可读格式记录它们是极其重要的。思考需要一个在一个抽象层面上，并且认真考虑所需完成的任务，只有个人和组织或许更有动力来完成一个多设备自动化。

## Configuration Management \| 配置管理

* 配置管理是自动化最常见的任务
* 当提到配置管理时，通常指部署、上传和管理设备的配置状态。这包括从VLAN配置这类的简单配置任务到复杂的工作流，如配置架顶交换机、防火墙、负载均衡和高级安全基础设置，再到配置三层架构应用 \(three-tier applications\)
* 这里作者提出一个有意思的观点：_As you can see already through the different forms of automation that are read-only, you do not need to start your automation journey by pushing configurations._ 作者告诉读者学习网络自动化不一定是从推送配置开始，原因在于我们只是在花费无数时间推送相同的变化到一些有限数量的路由器和交换机。

后面的三个类型承接上面的【Data Collection】

## Compliance \| 合规性

* 与许多形式的自动化一样，使用任何类型的自动化工具进行配置变更都被视为一种风险，但是它的风险程度还是低于手工配置的风险程度的
  * 虽然进行手动更改可以说风险更大，但可以选择从数据收集、监控和配置构建开始，这些都是只读和低风险的操作
  * 笔者理解的只读就是，一种查询式或者报告式的自动化，更多是一种提供信息、查询信息的自动化，帮助网工或管理员更快速的排查故障，不涉及网路拓扑、配置的变更
* 处于收集状态的数据的使用是一个低风险案例，该案例是配置合规性检查\(configuration compliance checks\)和配置验证\(configuration validation\)

  * 部署的配置是否符合安全要求？
  * 是否配置了所需的网络？
  * 某个协议是否被禁用？

  当你能够控制正在部署的工具时，就更有可能验证某些配置是正确还是错误。可以从小事做起，例如从合规性检查开始，然后根据需要逐步增加更多的检查。

* 根据你正在检查的配置的合规性，由你决定下一步操作—它或许只是被记录\(gets logged\)下来，或许是执行一个能使你的应用程序能够自动修复的复杂操作。
* 建议
  * 网络自动化最好总是从简单的任务开始，但“意识到可能的情况\(being aware of what’s possible\)”也会增加重要价值；
  * 例如，如果只是通过记录或打印消息以查看接口的MTU值，但你已经准备好，当MTU不是理想值时，可以自动重新配置为正确的值；只需要在以配置的log/print消息下面增加几条消息用来使能自动配置的功能；
  * 所以，虽然重要的是从小的简单任务开始，但是要思考在未来还需要完善什么功能；

## Reporting \| 报告

* 一旦数据收集自动化，就想要开始构建一个自定义**动态**的报告；收集的数据被返回，一方面可能作为另一些配置管理任务的输入，另一方面可能也仅仅是用于创建报告。
* 报告可以很容易地由**模板**和将要被插入模板的**瞬时数据**\(来自设备\)生成，创建和使用报告模板的过程与前面的VLAN创建过程的例子是一样的。
* 由于使用基于文本的模板的简单特性，它可以以任何你想要的格式制作报告，包括但不限于：

  * 简单的文本文件
  * 可以轻松地在Github或其它Markdown阅读器上查看的Markdown文件
  * 为了方便查看而部署在web服务器上的HTML报告

  格式的选择都取决于你的要求。

* 事实上，我们也可以使用一个数据集合来生成任意类型的报告，可能是一些技术性报告和一些高级的管理报告。

## Troubleshooting \| 排障

* 传统排障我们不仅需要人工监视，还需要网工介入来寻找故障所在，而每个网工基本上都有自己的排障方法；一旦能够访问实时数据并且不需要对这些数据进行手工解析，自动排障就成为现实。
* 以OSPF排障为例，在任何环境中，需要考虑OSPF的一致性检查，例如邻接关系建立时需要查看是否为同一子网、接口是否有相同MTU、是否有相同的计时器和相同网络类型等；在传统排障时，我们需要分别登录设备，用CLI命令查看并对比信息，我们能否使用脚本或工具来代替手工排障？
* OSPF的邻接关系建立过程的一致性检查只是排障问题的冰山一角，即使加入了BGP邻接关系建立或者如果形成邻接关系，或检查路由表是否与预期相同等情况，依然也只是浮于诊断和排障任务的表面；
* 当你开始考虑所有可能的自动化类型时，开始想象一个闭环系统，这样的系统是以自动化的方式收集数据，然后以自动化的方式处理和分析数据，然后你以自动化的方式使用高级分析来排除故障。当这些事情开始以统一的方式发生在一起时，这就变成了一个闭环，完全改变了组织内的运维方式。

## 小结

正如网络自动化有多种类型，它不仅限于更快的配置部署。下面的话题主要关于**自动化工具**和**应用程序**与网络设备**通信**的几种**不同方式**，从SSH开始，到NETCONF和基于HTTP的RESTful API。

